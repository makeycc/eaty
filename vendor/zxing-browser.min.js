(function (global) {
    class BrowserMultiFormatReader {
        constructor() {
            this._stream = null;
            this._stopped = false;
            this._detector = typeof BarcodeDetector !== 'undefined'
                ? new BarcodeDetector({
                    formats: [
                        'qr_code',
                        'code_128',
                        'code_39',
                        'ean_13',
                        'ean_8',
                        'upc_a',
                        'upc_e',
                    ],
                })
                : null;
        }

        async decodeOnceFromVideoDevice(deviceId, video) {
            if (!this._detector) throw new Error('BarcodeDetector API is not available');
            this._stopped = false;

            const constraints = {
                video: deviceId
                    ? { deviceId: { exact: deviceId } }
                    : { facingMode: 'environment' },
            };

            this._stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = this._stream;
            await video.play();

            return new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => {
                    if (this._stopped) return;
                    this._stopped = true;
                    reject(new Error('Timed out waiting for barcode'));
                }, 15000);

                const scanFrame = async () => {
                    if (this._stopped) return;
                    try {
                        const detections = await this._detector.detect(video);
                        if (detections && detections.length > 0) {
                            this._stopped = true;
                            clearTimeout(timeoutId);
                            resolve({ text: detections[0].rawValue });
                            return;
                        }
                    } catch (err) {
                        this._stopped = true;
                        clearTimeout(timeoutId);
                        reject(err);
                        return;
                    }
                    requestAnimationFrame(scanFrame);
                };

                requestAnimationFrame(scanFrame);
            });
        }

        reset() {
            this._stopped = true;
            if (this._stream) {
                this._stream.getTracks().forEach((track) => track.stop());
                this._stream = null;
            }
        }
    }

    global.ZXingBrowser = global.ZXingBrowser || {};
    global.ZXingBrowser.BrowserMultiFormatReader = BrowserMultiFormatReader;
})(typeof window !== 'undefined' ? window : this);
